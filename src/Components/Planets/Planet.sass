@use "sass:math"
@import 'src/variables.module.sass'

.planet
  perspective: 200vmin
  transform-style: preserve-3d
  width: $planet-radius * 2vmin
  height: $planet-radius * 2vmin
  top: 5vmin
  left: 5vmin

.planet:hover
  .sphere
    animation-play-state: paused

.planet::before
  content: ''
  position: absolute
  width: 100%
  height: 100%
  top: 0%
  left: 0%
  background: rgb(91, 161, 214)
  background: rgba(1,1,1,0.3)
  background: radial-gradient(circle farthest-corner at 3% 0%, #c5d4f1 10%, rgb(91, 161, 214) 60%)
  border-radius: 50%
  transform: translateZ(1vmin)

.sphere
  transform-style: preserve-3d
  position: absolute
  animation: rotate 15s infinite linear
  transform: rotateY(0deg) rotateX(0deg)
  width: 100%
  height: 100%
  transform-origin: 50% 50%
  top: 0
  left: 0

.hemisphere
  position: absolute
  top: 0
  left: 0
  width: 100%
  height: 100%
  transform-style: preserve-3d
  transform-origin: 50% 50%
  transform: rotateX(90deg)

.hemisphere:nth-child(2)
  transform: rotateX(-90deg)

.island
  position: absolute
  width: $island-radius * 2vmin
  height: $island-radius * 2vmin
  transform-style: preserve-3d
  transform-origin: 50% 0
  top: 50%
  left: 10vmin

.plate
  width: 50%
  height: 50%
  position: absolute
  left: 50%
  top: 50%
  transform: translate(-50%,-50%)
  .land
    width: 100%
    height: 100%
    position: absolute
    border-radius: 50%

@function calc-width($layer)
  $planet-radius-sqr: $planet-radius * $planet-radius
  $island-radius-sqr: $island-radius * $island-radius
  $base-chord-distance: math.sqrt($planet-radius-sqr - $island-radius-sqr)
  @return 2 * (math.sqrt($planet-radius-sqr - ( math.pow($base-chord-distance + 0.11 * $layer, 2)) ))

@mixin layer-dimensions($layer)
  $length: calc-width($layer)
  height: #{$length}vmin
  width: #{$length}vmin

@mixin raise-island-layer($tilt: 0, $i)
  transform: rotateY(#{$tilt * 1deg}) translate(-50%, -50%) translateZ(#{$i * $shrink-factor * 1vmin})

@for $i from 1 through 25
  // z-elevations and island tilts
  .island
    .plate:nth-child(#{$i})
      @if $i % 2 == 0
        @include raise-island-layer($tilt: -1, $i: $i)
      @else
        @include raise-island-layer($tilt:  1, $i: $i)
  .island--no_tilt
    .plate:nth-child(#{$i})
      @include raise-island-layer($i: $i)
  // size tailoring
  .plate:nth-child(#{$i})
    @include layer-dimensions($i)

@keyframes rotate
  0%
    transform: rotateZ(-15deg) rotateX(0deg) rotateY(0deg)
    // transform: rotateX(0deg) rotateY(0deg)
  100%
    transform: rotateZ(-15deg) rotateX(0deg) rotateY(360deg)
    // transform: rotateX(0deg) rotateY(360deg)

@function calculate-translation($side)
  @return math.sqrt(math.div($planet-r2 * $side,  math.div($total-possible-random-positions, 4))) // 4 Quadrants on an xy graph

@function get-random-z-y($seed)
  $seed-z: $seed
  @while $seed-z > 25
    $seed-z: $seed-z - 25
  $trans-z: calculate-translation($seed-z)
  $seed-y: 25 - $seed-z
  $trans-y: calculate-translation($seed-y)

  // Ensure seeds go through all four quadrants equally
  // 0 ---- z+ y+ ---- 25 ---- z- y+ ---- 50 ---- z+ y- ---- 75 ---- z- y- ---- 100
  @if $seed > 25 and $seed < 50 or $seed > 75
    $trans-z: -$trans-z
  @if $seed > 50
    $trans-y: -$trans-y

  $point-angle: 0deg
  @if ($trans-y >=0 and $trans-z >= 0) or ($trans-y < 0 and $trans-z < 0)
    $point-angle: math.atan(math.div(math.abs($trans-z), math.abs($trans-y) ))
  @else
    $point-angle: math.atan(math.div(math.abs($trans-y), math.abs($trans-z) ))

  $quadrant-bonus: 0deg
  @if $trans-z >= 0 and $trans-y < 0
    $quadrant-bonus: 0deg
  @if $trans-z < 0 and $trans-y < 0
    $quadrant-bonus: 90deg
  @if $trans-z < 0 and $trans-y >= 0
    $quadrant-bonus: 180deg
  @if $trans-z >= 0 and $trans-y >= 0
    $quadrant-bonus: 270deg

  $chord-center-diff: math.asin(math.div($island-radius, $planet-radius))
  $rotate-x: $point-angle - $chord-center-diff + $quadrant-bonus
  @return ("rot-x": $rotate-x, "trans-y": $trans-y, "trans-z": $trans-z)

@mixin get-random-transformation($seed)
  $seeds: get-random-z-y($seed: $seed)
  transform: translateZ(#{map-get($seeds, "trans-z")}vmin) rotateZ(#{map-get($seeds, "rot-z")}deg) translateY(#{map-get($seeds, "trans-y")}vmin) rotateX(#{map-get($seeds, "rot-x")})

// Positionings
@for $i from 0 through $total-possible-random-positions
  $translations: get-random-z-y($seed: $i)
  .island--#{$i}
    .land
      border-top-right-radius: math.random(50) + 50 * 1%
      border-top-left-radius: math.random(50) + 50 * 1%
      border-bottom-right-radius: math.random(50) + 50 * 1%
      border-bottom-left-radius: math.random(50) + 50 * 1%
  @for $j from 0 through 360
    .island--#{$i}.island--rotate-z-#{$j}deg
      transform: translateZ(#{map-get($translations, "trans-z")}vmin) rotateZ(#{$j}deg) translateY(#{map-get($translations, "trans-y")}vmin) rotateX(#{map-get($translations, "rot-x")})
