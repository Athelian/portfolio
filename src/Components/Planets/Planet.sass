@use "sass:math"
@import 'src/variables.module.sass'

.planet
  perspective: 200vmin
  transform-style: preserve-3d
  width: $planet-diameter * 1vmin
  height: $planet-diameter * 1vmin
  top: 5vmin // hard to say if this is a variable or constant 5vmin
  left: 5vmin // hard to say if this is a variable or constant 5vmin

.planet:hover
  .sphere
    animation-play-state: paused

.planet::before
  content: ''
  position: absolute
  width: 100%
  height: 100%
  top: 0%
  left: 0%
  border-radius: 50%
  transform: translateZ(1vmin)

.sphere
  transform-style: preserve-3d
  position: absolute
  animation: rotate 15s infinite linear
  transform: rotateY(0deg) rotateX(0deg)
  width: 100%
  height: 100%
  transform-origin: 50% 50%
  top: 0
  left: 0

.hemisphere
  position: absolute
  top: 0
  left: 0
  width: 100%
  height: 100%
  transform-style: preserve-3d
  transform-origin: 50% 50%
  transform: rotateX(90deg)

.hemisphere:nth-child(2)
  transform: rotateX(-90deg)

.island
  position: absolute
  transform-style: preserve-3d
  transform-origin: 50% 0
  top: 50%

.plate
  width: 50%
  height: 50%
  position: absolute
  left: 50%
  top: 50%
  transform: translate(-50%,-50%)
  transform-style: preserve-3d

.land__window
  transform-style: preserve-3d
  position: absolute
  left: 50%
  top: 0%
  transform: translate(-50%, 0%)

.land
  position: absolute
  left: 50%

.test
  width: 100%
  height: 100%
  // background-color: rgb(91, 214, 171)
  background-color: red
  position: absolute

.test-up
  bottom: 0

@mixin gen-island($name, $island-layers, $island-diameter, $rotation, $flip: false)
  $island-radius: math.div($island-diameter, 2)
  $island-radius-squared: math.pow($island-radius, 2)
  $island-height: $planet-radius - math.sqrt($planet-radius-squared - $island-radius-squared) // The final height added by the layers piling on top of one another
  $shrink-factor: math.div($island-height, $island-layers) // The factor by which to raise the next layer above the previous
  $base-chord-distance: math.sqrt($planet-radius-squared - $island-radius-squared)
  $layer-offset-remainder: 0.6
  @debug $island-layers
  @debug $island-radius
  @debug $island-height
  @debug $shrink-factor
  .island--#{$name}
    width: $island-diameter * 1vmin
    height: $island-diameter * 1vmin
    left: (math.div($planet-diameter - $island-diameter, 2)) * 1vmin
    .land
      height: $island-diameter * 1vmin
      width: $island-diameter * 1vmin
  @for $i from 0 through $island-layers - 1
    $island-layer-radius: math.sqrt($planet-radius-squared - ( math.pow($base-chord-distance + $shrink-factor * $i, 2)) )
    $island-layer-radius-next: math.sqrt($planet-radius-squared - ( math.pow($base-chord-distance + $shrink-factor * ($i + 1), 2)) )
    $island-layer-diameter: 2 * $island-layer-radius
    $window-length: $island-layer-radius - math.sqrt($planet-radius-squared - ( math.pow($base-chord-distance + $shrink-factor * ($i + 1), 2)) )
    .island--#{$name}
      .plate:nth-child(#{$i})
        $position: $i % 6
        height: #{$island-layer-diameter * 1vmin}
        width: #{$island-layer-diameter * 1vmin}
        .test
          width: $shrink-factor * 1vmin
          left: calc(50% - math.div($shrink-factor, 2) * 1vmin)
          transform: rotateY(90deg) translateX(math.div($shrink-factor, 2) * 1vmin)
          height: math.div(math.div($island-layer-diameter,2) - ($island-layer-radius-next - $layer-offset-remainder), 1) * 1vmin
          // mask: radial-gradient(circle #{($island-layer-radius-next * 1vmin)},transparent 100%,#fff 100%)
        @if $flip
          transform: translate(-50%, -50%) rotateY(-0.0deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        @else
          transform: translate(-50%, -50%) rotateY(-0.0deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        // @if $position == 0
        //   @if $flip
        //     transform: translate(-50%, -50%) rotateY(0.3deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        //   @else
        //     transform: translate(-50%, -50%) rotateY(0.3deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        // @if $position == 1
        //   @if $flip
        //     transform: translate(-50%, -50%) rotateY(-0.3deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        //   @else
        //     transform: translate(-50%, -50%) rotateY(-0.3deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        // @if $position == 2
        //   @if $flip
        //     transform: translate(-50%, -50%) rotateY(0.2deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        //   @else
        //     transform: translate(-50%, -50%) rotateY(0.2deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        // @if $position == 3
        //   @if $flip
        //     transform: translate(-50%, -50%) rotateY(-0.2deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        //   @else
        //     transform: translate(-50%, -50%) rotateY(-0.2deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        // @if $position == 4
        //   @if $flip
        //     transform: translate(-50%, -50%) rotateY(0.1deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        //   @else
        //     transform: translate(-50%, -50%) rotateY(0.1deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        // @if $position == 5
        //   @if $flip
        //     transform: translate(-50%, -50%) rotateY(-0.1deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(0deg)
        //   @else
        //     transform: translate(-50%, -50%) rotateY(-0.1deg) translateZ(#{$i * $shrink-factor * 1vmin}) rotateX(180deg)
        .land__window
        .land__window
          height: 100%
          width: 100%
          @if $i == $island-layers - 1
            mask: radial-gradient(circle 0vmin,transparent 100%,#fff 100%)
          @else
            mask: radial-gradient(circle #{($island-layer-radius-next - $layer-offset-remainder * 1vmin)},transparent 100%,#fff 100%)
        > *
          height: 100%
        .land
          transform: translate(-50%, #{math.div(($island-diameter - $island-layer-diameter), 2) * -1vmin}) rotate($rotation * 1deg)
        .land--rotated
          transform: translate(-50%, #{($window-length - $island-layer-radius - $island-radius) * 1vmin} ) rotate($rotation * 1deg)

@function calculate-translation($side)
  @return math.sqrt(math.div($planet-radius-squared * $side,  math.div($total-possible-random-positions, 4))) // 4 Quadrants on an xy graph

@function get-random-z-y($seed, $island-radius)
  $seed-z: $seed
  @while $seed-z > $quadrant-boundary
    $seed-z: $seed-z - $quadrant-boundary
  $trans-z: calculate-translation($seed-z)
  $seed-y: $quadrant-boundary - $seed-z
  $trans-y: calculate-translation($seed-y)

  // Ensure seeds go through all four quadrants equally
  // 0 ---- z+ y+ ---- 25 ---- z- y+ ---- 50 ---- z+ y- ---- 75 ---- z- y- ---- 100
  @if $seed >= $first-quadrant-limit and $seed < $second-quadrant-limit or $seed >= $third-quadrant-limit
    $trans-z: -$trans-z
  @if $seed >= $second-quadrant-limit
    $trans-y: -$trans-y

  $point-angle: 0deg
  @if ($trans-y >=0 and $trans-z >= 0) or ($trans-y < 0 and $trans-z < 0)
    $point-angle: math.atan(math.div(math.abs($trans-z), math.abs($trans-y) ))
  @else
    $point-angle: math.atan(math.div(math.abs($trans-y), math.abs($trans-z) ))

  $quadrant-bonus: 0deg
  @if $trans-z >= 0 and $trans-y < 0
    $quadrant-bonus: 0deg
  @if $trans-z < 0 and $trans-y < 0
    $quadrant-bonus: 90deg
  @if $trans-z < 0 and $trans-y >= 0
    $quadrant-bonus: 180deg
  @if $trans-z >= 0 and $trans-y >= 0
    $quadrant-bonus: 270deg

  $chord-center-diff: math.asin(math.div($island-radius, $planet-radius))
  $rotate-x: $point-angle - $chord-center-diff + $quadrant-bonus
  @return ("rot-x": $rotate-x, "trans-y": $trans-y, "trans-z": $trans-z)

@keyframes rotate
  0%
    transform: rotateZ(-23.5deg) rotateX(0deg) rotateY(0deg)
  100%
    transform: rotateZ(-23.5deg) rotateX(0deg) rotateY(360deg)
