@use "sass:math"
@import 'src/variables.module.sass'
@import 'src/Components/Planets/Planet.sass'
@import './Components/Clouds.sass'
@import './Components/Islands.sass'

$earth-rotation-speed: 0s

$cloud-scale-factor: 0.3
$cloud-rotation-speed: 16s
$cloud-layer-separation-distance: 0.1vmin
$cloud-total-depth: $cloud-layers * $cloud-layer-separation-distance
$cloud-separation-from-earth: 1vmin
$cloud-fin-scale-factor: 0.05

.landmark
  background-color: violet
  transform: translateZ(0vmin) translate(50%, 50%)
  width: 38px
  height: 48px

.earth-container
  position: relative
  z-index: 1
  clip-path: circle(math.div($planet-diameter, 2) - math.div($layer-offset-remainder, 2) * 1vmin)
  .planet
    &:hover
      .sphere, .island--asia .surface
        animation-play-state: paused
    &::before
      background: rgb(91, 161, 214)
      content: ''
      position: absolute
      width: 100%
      height: 100%
      border-radius: 50%
      // transform: translateZ(1vmin) // unclear what the purpose of this is
  .sphere
    animation: rotate-earth $earth-rotation-speed linear infinite
    .land
      background-color: rgb(91, 214, 171)
    .island--asia // fix bad cut on Europe and Asia
      > .plate
        > .surface
          animation: rotate-asia-offset $earth-rotation-speed linear infinite

.planet--clouds
  animation: elevate-cloud $cloud-rotation-speed linear infinite
  will-change: transform // as we are elevating
  pointer-events: none
  position: absolute
  width: ($planet-diameter * 1vmin) + $cloud-total-depth + $cloud-separation-from-earth
  height: ($planet-diameter * 1vmin) + $cloud-total-depth + $cloud-separation-from-earth
  perspective: none // If there is a perspective, the cloud may not turn around quickly enough around the side
  @for $i from 1 through 36
    $rotation: $i * 10
    &--y-rotation--#{$rotation}
      animation: elevate-cloud $cloud-rotation-speed math.div($rotation, 360) * -1 * $cloud-rotation-speed linear infinite
  .sphere
    animation: rotate-earth $cloud-rotation-speed linear infinite
    .hemisphere
      transform: none
      .cloud
        > div, &:after
          background-color: white
          position: absolute
        &:after
          content: ""
      @each $cloud in $clouds
        $center-to-apex: map-get($cloud, "center-to-apex")
        .cloud--#{map-get($cloud, "label")}
          height: map-get($cloud, "height")
          width: map-get($cloud, "width")
          transform: rotateY(90deg) translate(0, -50%) translateZ(math.div(map-get($cloud, "width"), 2) * -1)
          > div
            clip-path: map-get($cloud, "path")
            height: 100%
            width: 100%
          &:after
            height: map-get($cloud, "height") * (1 - $cloud-fin-scale-factor) // Remove 5% height to ensure no overscaling
      @for $scale-factor from 1 through 30
        $scale: math.div(math.div($scale-factor, 10), 20) // Arbitrary division value
        .cloud--scale-#{$scale-factor}
          &:after
            width: math.div($cloud-total-depth, $scale)
            left: calc(50% - math.div(math.div($cloud-total-depth, $scale), 2))
        @each $cloud in $clouds
          .cloud--#{map-get($cloud, "label")}.cloud--scale-#{$scale-factor}
            > div
              transform: scale($scale)
            @for $i from 1 through $cloud-layers
              $direction: 1
              $factor: $i
              @if $i > math.div($cloud-layers, 2)
                $direction: -1
                $factor: $factor - math.div($cloud-layers, 2)
              div:nth-child(#{$i})
                transform: translateZ($cloud-layer-separation-distance * $direction * $factor) scale($scale)
            &:after
              // translate from center to apex by the appropriate amount, accounting for scale factor.
              transform: translate(map-get($cloud, "center-to-apex") * $scale * 1px, math.div($cloud-fin-scale-factor, 2) * 100% ) rotateY(90deg) scale($scale) 

@keyframes elevate-cloud
  0%
    z-index: 1
  100%
    z-index: 0
@keyframes rotate-earth
  0%
    transform: rotateZ(-23.5deg) rotateX(0deg) rotateY(0deg)
  100%
    transform: rotateZ(-23.5deg) rotateX(0deg) rotateY(360deg)
@keyframes rotate-asia-offset
  0%
    transform: rotateY(0deg)
  1%
    transform: rotateY(0deg)
  22%
    transform: rotateY(-30deg) translateZ(8vmin)
  60%
    transform: rotateY(-0deg) translateZ(0vmin)

$continents: map-get($earth, "continents")
$islands: map-keys($continents)
@each $island in $islands
  $props: map-get($continents, $island)
  @include gen-island($name: $island, $island-layers: map-get($props, "layers"), $island-diameter: map-get($props, "diameter"), $rotation: map-get($props, "rotation"), $z-rotation: map-get($props, "z-rotation"), $position: map-get($props, "position"))
