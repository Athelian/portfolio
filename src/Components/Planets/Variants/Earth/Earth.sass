@use "sass:math"
@import 'src/variables.module.sass'
@import 'src/Components/Planets/Planet.sass'
@import './Components/Clouds.sass'
@import './Components/Islands.sass'

$earth-rotation-speed: 24s
$earth-rotation-speed: 12s

$cloud-scale-factor: 0.3
// $cloud-rotation-speed: 38s
$cloud-rotation-speed: 16s
$cloud-layer-separation-distance: 0.1vmin
$cloud-total-depth: $cloud-layers * $cloud-layer-separation-distance
$cloud-separation-from-earth: 2vmin
$cloud-fin-scale-factor: 0.05

.planet--flag
  z-index: 1
  position: absolute
  animation: elevate-flag $earth-rotation-speed math.div(44, 360) * -1 * $earth-rotation-speed steps(2,start) infinite
  .sphere
    animation: rotate-earth $earth-rotation-speed linear infinite
    .landmark
      $translations: get-random-z-y(160, 2)
      transform:  translateZ(#{map-get($translations, "trans-z")}vmin ) rotateZ(32deg) translateY(#{map-get($translations, "trans-y")}vmin)  rotateX(#{map-get($translations, "rot-x")})
      width: 2vmin
      height: 2vmin
      left: (math.div($planet-diameter - 2, 2)) * 1vmin
      .contain-flag 
        position: absolute
        height: auto
        transform: rotateX(22deg)
        .pole
          background-color: gray
          border: 0.1vmin solid #636262
          border-radius: 1vmin
          width: 1vmin
          height: 20vmin
        .pole::before
          position: absolute
          top: -1.4vmin
          left: -.5vmin
          display: block
          background-color: gray
          border-radius: 50%
          border: .1vmin solid #636262
          width: 2vmin
          height: 2vmin
          content:''
        .flag 
          position: absolute 
          top: .8vmin
          z-index: 10
          background-color: #eb573b
          border: .1vmin solid #d64b38
          width: 22vmin
          height: 11vmin
          background: linear-gradient(180deg, transparent, transparent 4.4vmin, #c8102e 4.4vmin, #c8102e 6.6vmin, transparent 6.6vmin, transparent 100%), linear-gradient(90deg, transparent, transparent 9.9vmin, #c8102e 9.9vmin, #c8102e 12.1vmin, transparent 12.1vmin, transparent 100%), linear-gradient(180deg, transparent, transparent 3.7vmin, #FFF 3.7vmin, #FFF 7.3vmin, transparent 7.3vmin, transparent 100%), linear-gradient(90deg, transparent, transparent 9.2vmin, #FFF 9.2vmin, #FFF 12.8vmin, transparent 12.8vmin, transparent 100%), linear-gradient(26.56505deg, transparent, transparent 9.1vmin, #c8102e 9.1vmin, #c8102e 9.8vmin, transparent 9.8vmin, transparent 100%) 0 0/11vmin 100% no-repeat, linear-gradient(-26.56505deg, transparent, transparent 9.8vmin, #c8102e 9.8vmin, #c8102e 10.6vmin, transparent 10.6vmin, transparent 100%) 11vmin 0/11vmin 100% no-repeat, linear-gradient(26.56505deg, transparent, transparent 9.8vmin, #c8102e 9.8vmin, #c8102e 10.6vmin, transparent 10.6vmin, transparent 100%) 11vmin 5.5vmin/11vmin 100% no-repeat, linear-gradient(-26.56505deg, transparent, transparent 9.1vmin, #c8102e 9.1vmin, #c8102e 9.8vmin, transparent 9.8vmin, transparent 100%) 0 5.5vmin/11vmin 100% no-repeat, linear-gradient(27deg, transparent, transparent 8.7vmin, #FFF 8.7vmin, #FFF 10.9vmin, transparent 10.9vmin, transparent 100%), linear-gradient(153deg, transparent, transparent 8.7vmin, #FFF 8.7vmin, #FFF 10.9vmin, transparent 10.9vmin, transparent 100%), #012169
          

.earth-container
  position: relative
  z-index: 2
  clip-path: circle(math.div($planet-diameter, 2) - math.div($layer-offset-remainder, 2) * 1vmin)
  .planet
    &:hover
      .sphere, .island--asia .surface
        animation-play-state: paused
    &::before
      background: rgb(91, 161, 214)
      content: ''
      position: absolute
      width: 100%
      height: 100%
      border-radius: 50%
      // transform: translateZ(1vmin) // unclear what the purpose of this is
  .sphere
    animation: rotate-earth $earth-rotation-speed linear infinite
    .land
      background-color: rgb(91, 214, 171)
    .island--asia // fix bad cut on Europe and Asia
      > .plate
        > .surface
          animation: rotate-asia-offset $earth-rotation-speed linear infinite

.planet--clouds
  animation: elevate-cloud $cloud-rotation-speed steps(2,start) infinite
  will-change: transform // as we are elevating
  pointer-events: none
  position: absolute
  width: ($planet-diameter * 1vmin) + $cloud-total-depth + $cloud-separation-from-earth
  height: ($planet-diameter * 1vmin) + $cloud-total-depth + $cloud-separation-from-earth
  perspective: none // If there is a perspective, the cloud may not turn around quickly enough around the side
  @for $i from 1 through 36
    $rotation: $i * 10
    &--y-rotation--#{$rotation}
      animation: elevate-cloud $cloud-rotation-speed math.div($rotation, 360) * -1 * $cloud-rotation-speed steps(2,start) infinite
  .sphere
    animation: rotate-earth $cloud-rotation-speed linear infinite
    .hemisphere
      transform: none
      .cloud
        > div, &:after
          background-color: white
          position: absolute
        &:after
          content: ""
      @each $cloud in $clouds
        $center-to-apex: map-get($cloud, "center-to-apex")
        .cloud--#{map-get($cloud, "label")}
          height: map-get($cloud, "height")
          width: map-get($cloud, "width")
          transform: rotateY(90deg) translate(0, -50%) translateZ(math.div(map-get($cloud, "width"), 2) * -1)
          > div
            clip-path: map-get($cloud, "path")
            height: 100%
            width: 100%
          &:after
            height: map-get($cloud, "height") * (1 - $cloud-fin-scale-factor) // Remove 5% height to ensure no overscaling
      @for $scale-factor from 1 through 30
        $scale: math.div(math.div($scale-factor, 10), 20) // Arbitrary division value
        .cloud--scale-#{$scale-factor}
          &:after
            width: math.div($cloud-total-depth, $scale)
            left: calc(50% - math.div(math.div($cloud-total-depth, $scale), 2))
        @each $cloud in $clouds
          .cloud--#{map-get($cloud, "label")}.cloud--scale-#{$scale-factor}
            > div
              transform: scale($scale)
            @for $i from 1 through $cloud-layers
              $direction: 1
              $factor: $i
              @if $i > math.div($cloud-layers, 2)
                $direction: -1
                $factor: $factor - math.div($cloud-layers, 2)
              div:nth-child(#{$i})
                transform: translateZ($cloud-layer-separation-distance * $direction * $factor) scale($scale)
            &:after
              // translate from center to apex by the appropriate amount, accounting for scale factor.
              transform: translate(map-get($cloud, "center-to-apex") * $scale * 1px, math.div($cloud-fin-scale-factor, 2) * 100% ) rotateY(90deg) scale($scale) 
@keyframes elevate-flag
  0%
    z-index: 2
  100%
    z-index: 1
@keyframes elevate-cloud
  0%
    z-index: 2
  100%
    z-index: 1
@keyframes rotate-earth
  0%
    transform: rotateZ(-23.5deg) rotateX(0deg) rotateY(0deg)
  100%
    transform: rotateZ(-23.5deg) rotateX(0deg) rotateY(360deg)
@keyframes rotate-asia-offset
  0%
    transform: rotateY(0deg)
  1%
    transform: rotateY(0deg)
  22%
    transform: rotateY(-30deg) translateZ(8vmin)
  60%
    transform: rotateY(-0deg) translateZ(0vmin)

$continents: map-get($earth, "continents")
$islands: map-keys($continents)
@each $island in $islands
  $props: map-get($continents, $island)
  @include gen-island($name: $island, $island-layers: map-get($props, "layers"), $island-diameter: map-get($props, "diameter"), $rotation: map-get($props, "rotation"), $z-rotation: map-get($props, "z-rotation"), $position: map-get($props, "position"))
